\documentclass[bachelor, och, coursework]{SCWorks}
% параметр - тип обучения - одно из значений:
%    spec     - специальность
%    bachelor - бакалавриат (по умолчанию)
%    master   - магистратура
% параметр - форма обучения - одно из значений:
%    och   - очное (по умолчанию)
%    zaoch - заочное
% параметр - тип работы - одно из значений:
%    referat    - реферат
%    coursework - курсовая работа (по умолчанию)
%    diploma    - дипломная работа
%    pract      - отчет по практике
%    pract      - отчет о научно-исследовательской работе
%    autoref    - автореферат выпускной работы
%    assignment - задание на выпускную квалификационную работу
%    review     - отзыв руководителя
%    critique   - рецензия на выпускную работу
% параметр - включение шрифта
%    times    - включение шрифта Times New Roman (если установлен)
%               по умолчанию выключен
\usepackage[T2A]{fontenc}
\usepackage[cp1251]{inputenc}
\usepackage{graphicx}

\usepackage[sort,compress]{cite}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{fancyvrb}
\usepackage{longtable}
\usepackage{array}
\usepackage{minted}
\setminted[cpp]{fontsize=\small,breaklines=true, style=bw, linenos}
\setminted[c]{fontsize=\small,breaklines=true, style=bw, linenos}
\setminted[python]{fontsize=\small,breaklines=true, style=bw, linenos}
\usepackage[english,russian]{babel}
\usepackage{tempora}

\usepackage[colorlinks=true]{hyperref}


\newcommand{\eqdef}{\stackrel {\rm def}{=}}

\newtheorem{lem}{Лемма}

\begin{document}

\section{Управление памятью на основе регионов}

\subsection{Мотивировка}

Текущая реализация абстрактного синтаксического дерева имеет следующие недостатки:

\begin{enumerate}
\item{Выделение памяти стандартным методом может значительно фрагментировать оперативную память, затрудняя доступ к ней.}
\item{Любое выделение и удаление памяти требует вмешательства системных
вызовов, что может стать причиной дополнительных издержек во время
работы программы.}
\item{Программист не имеет возможности ручного управления выделяемой им
памятью.}
\end{enumerate}

Избавиться от этих недостатков можно используя различные оптимизации. В рамках этой работы воспользуемся управлением памятью на основе, так
называемых, регионов (арен, зон)\cite{wangmanaging}.

Под регионом далее будем понимать непрерывную область памяти, содержащую внутри себя объекты. При запуске программы выделим регион некоторого размера, при необходимости увеличивая его размер в некоторое постоянное
число раз.

Этот подход имеет следующие преимущества:

\begin{enumerate}
\item{Элементы располагаются последовательно, в связи с чем минимизируется
фрагментация и упрощается доступ к объектам.}
\item{Выделение и освобождение памяти выполняется с минимальными издержками.}
\item{Программисту предоставляется большая свобода для управления выделенной памятью.}
\end{enumerate}

\subsection{Построение}

Формально определим требования к системе:

\begin{enumerate}
\item{Регион должен представлять из себя некоторый непрерывный участок размера $n$ байт (в начальный момент времени размер равен некоторой начальной величине $n_0$).}
\item{При обращении к региону он должен предоставить $k$ байт памяти и вернуть
некоторый идентификатор этого участка для последующего обращения..}
\item{ При заполнении региона должна быть возможность увеличить объем доступной памяти в некоторое число раз, которое далее будем называть
коэффициентом увеличения.}
\item {Должна быть доступна возможность эффективного освобождения всей
выделенной регионом памяти.}
\end{enumerate}

Так как выделение нового участка потенциально может сопровождаться изменением адресов объектов,
 то необходимо организовать доступ к ним независимо от первоначального адреса. Для этого для каждого объекта будем получать
 доступ к нему через некоторый индекс.
 
 Кроме того, коэффициент увеличения должен быть выбран таким образом, чтобы был соблюден баланс между оптимальным объемом выделенной
 памяти и частотой системных вызовов.
 
\subsection{Определение структуры}
 
 Определим нашу структуру следующим образом:
 
 \begin{minted}{cpp}
 typedef struct arena {
// Указатель на начало региона
	struct node* arena;
	// Размер региона
	unsigned int size;
	// Объем выделенной регионом памяти
 	unsigned int allocated;
} arena;
 \end{minted}
 
\subsection{Инициализация}
 
 Теперь определим функцию \mintinline[fontsize = \normalsize]{cpp}{arena_construct}, выполняющую начальную
 инициализацию состояния региона:
 
 \begin{minted}{cpp}
int arena_construct (arena* arena) {
	// Начальный размер региона равен некоторой постоянной, равной DEFAULT_ARENA_SIZE
	arena->size = DEFAULT_ARENA_SIZE;
	arena->allocated = 0;
	// Выделим необходимое число памяти
	arena->arena = malloc(sizeof(node) * DEFAULT_ARENA_SIZE);
	// Если выделение прошло неудачно - вернем в качестве кода ошибки отличное от 0 значение.
	if (arena->arena == NULL) {
	return (!0);
	}
	return 0;
}
  \end{minted}

\subsection{Выделение памяти}

После выделения некоторого объема памяти возможно обращение к ней.
Определим это обращение с помощью функции \mintinline[fontsize = \normalsize]{cpp}{arena_allocate}:

\begin{minted}{cpp}
int arena_allocate (arena* arena, unsigned int count) {
	//Если места в регионе недостаточно
	if (arena->allocated + count >= arena->size) {
		// Определим новый размер региона
		unsigned int newSize = MULTIPLY_FACTOR * arena->size;
		// Выделим регион большего размера и освободим ранее занятую память
		node* newArena = realloc(arena->arena,
		newSize * sizeof(node));
		if (NULL == newArena) {
			return -1;
		}
		arena->arena = newArena;
		arena->size = newSize;
	}
	// В качестве результата вернем индекс первого свободного участка региона
	unsigned int result = arena->allocated;
	// Сместим индекс на объем выделенной памяти
	arena->allocated += count;
	// Вернем результат
	return result;
}
\end{minted}

Отметим, что наиболее часто значением \mintinline[fontsize = \normalsize]{cpp}{MULTIPLY_FACTOR} оказывается числа
$1.5$ и $2$. Это позволяет достичь амортизационно константного времени выполнения операции выделения памяти \cite{FBOS}.

\subsection{Освобождение выделенной памяти}

Наконец, реализуем освобождение выделенной региону памяти с помощью функции \mintinline[fontsize = \normalsize]{cpp}{arena_free}

\begin{minted}{cpp}
void arena_free (arena* arena) {
	if (arena->arena != NULL)
	free(arena->arena);
	arena->arena = NULL;
}
\end{minted}

\subsection{Модификация абстрактного синтаксического дерева}

Осталось изменить исходный код программы, чтобы обеспечить выделение памяти с помощью полученной нами структуры данных.
Для этого воспользуемся директивой \mintinline[fontsize = \normalsize]{cpp}{%param} и заявим в качестве параметра переменную типа \mintinline[fontsize = \normalsize]{cpp}{arena*}. В функциях \mintinline[fontsize = \normalsize]{cpp}{eval, newnum, newast} внесем изменения, чтобы обеспечить выделение памятью с помощью написанных ранее
функций.
С полным кодом программы можно ознакомиться в приложении \ref{app:A}. 

\subsection{Сборка проекта}

Теперь проект можно собрать, незначительно изменив \texttt{Makefile}:

\begin{minted}{cpp}
calc.out: calc.l calc.y arena_ast.h
		bison -d calc.y
		flex calc.l
		cc -o $@ calc.tab.c lex.yy.c arena_ast.c arena.c
\end{minted}

и запустить. Результат работы программы представлен на рис. \ref{pic:6}. 

\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{naivetest.png}
\caption{Демонстрация работы программы}
\label{pic:6}
\end{figure}

\section{Сравнение полученных реализаций}

Проведем анализ производительности полученных версий анализатора. В
качестве данных для тестирования возьмем выражения вида $\underbrace{2+2+2\dots+2}_n$ 
для $n = 1 \dots 100$ с шагом $1$. Для вычисления времени выполнения воспользуемся библиотекой
\texttt{time} Python 3.9.5. Автоматизацию обеспечим с помощью
библиотеки \texttt{subprocess}. Получим следующий код:

\inputminted{python}{test.py}

Кроме того, отметим, что в ранее написанные программы были внесены некоторые изменения для проведения эксперимента. Ознакомиться с ними
можно в приложении \ref{app:A}.

Ознакомиться с полным исходным кодом программы, осуществляющей
исследование производительности можно в приложении \ref{app:B}.

Для большей наглядности графики интерполированы полиномом с помощью функции \texttt{polyfit} библиотеки \texttt{numpy}.

Ознакомиться с полным исходным кодом программы, осуществляющей
анализ полученных результатов можно в приложении \ref{app:C}.

Результаты исследования изображены на рис. \ref{pic:7}.

\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{benchmark.png}
\caption{Сравнение полученных результатов}
\label{pic:7}
\end{figure}

Исследование показало, что использование абстрактных синтаксических
деревьев позволяет уменьшить время работы программы более чем в $5$ раз, что
существенно заметно для выражений любой длины.

Также из графиков видно, что в рамках данной работы не удалось добиться большей производительности при управлении памятью на основе регионов.
Тем не менее, она все еще может считаться более предпочительной ввиду перечисленных ранее преимуществ.

\conclusion

В ходе данной работы:

\begin{enumerate}
\item{Были изучены теоретические основы построения лексических и синтаксических анализаторов.}
\item{Проанализированы особенности реализации лексических и синтаксических анализаторов.}
\item{Были изучены принципы работы генераторов лексического и синтаксического анализа на примере Flex и GNU Bison.}
\item{Были созданы лексический и синтаксический анализаторы для анализа
математического выражения.}
\item{Было изучено понятие абстрактного синтаксического дерева.}
\item{Проведен анализ производительности полученных реализаций.}
\end{enumerate}

Таким образом, все поставленные в рамках работы задачи выполнены.

Результаты исследования показали, что абстрактные синтаксические деревья позволяют добиться увеличения производительности в $5$--$6$ раз.

А это, в свою очередь, позволяет утверждать о том, что концепция абстрактных синтаксических деревьев является крайне важной в информатике и
ее приложениях, в частности, при создании синтаксических анализаторов.

\bibliographystyle{gost780uv}
\bibliography{thesis}

\appendix

\section{Flash-носитель с исходным кодом программ, использующихся в работе}\label{app:A}

\begin{itemize}
\item[]{\textbf{Папка} \texttt{src} содержит оригинальный исходный код программы:}

\begin{description}
\item{\textbf{Папка} \texttt{naive} — реализация без АСД}
\item{\textbf{Папка} \texttt{naiveast} — реализация с АСД}
\item{\textbf{Папка} \texttt{arena} — реализация с АСД на основе региона}
\end{description}	
	
\item[]{\textbf{Папка} \texttt{extsrc} содержит измененный исходный код, необходимый для исследования производительности:}

\begin{description}
\item{\textbf{Папка} \texttt{naive} — реализация без АСД}
\item{\textbf{Папка} \texttt{naiveast} — реализация с АСД}
\item{\textbf{Папка} \texttt{arena} — реализация с АСД на основе региона}
\end{description}	

\end{itemize}

\section{Исходный код программы на Python, осуществляющей исследование
производительности полученных реализаций}\label{app:B}

\inputminted{python}{test.py}

\section{Исходный код программы на Python, осуществляющей анализ
полученных результатов}\label{app:C}

\inputminted{python}{graph.py}

\end{document}
